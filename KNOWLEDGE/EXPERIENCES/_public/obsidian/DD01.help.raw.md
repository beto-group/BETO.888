








## ENIGMAS
----


What am I doing wrong here? I built the repo and put it into my plugin folder. I'm using this syntax and I just get an empty bullet. Or does it not show anything yet?



Oh, I see it in the dev console. Is that right?


Will we be able to produce the text content of objects? Like say a block with a specific tag?


my first guess is that you need a render function around it to actually see the result in the codeblock. i haven't played with it yet (no idea how to build it correctly) so i can't give a more clear answer

I‚Äôve been poking around trying to figure it out but no luck yet üòÖ


if you run the same command in the dev tools, do you get a response to the queries

plus datacorejs probably assumes some type of html return

i haven't come across any actual UI yet like we have with dataviews lists, tables, etc, everything has to be rendered by handed

Yes, they do work in the dev console!

That‚Äôs good news. Your syntax is right ü§ì

I'm liking the look of the grouped headings in the table report

what is the syntax for the block?

This is the full block I'm using including some grouping logic:

```
datacorejsx

const COLUMNS = [
    { id: "Game", value: (game) => game.$link },
    { id: "Time Played", value: (game) => game.value("time played") ?? game.value("time-played") },
    { id: "Length", value: (game) => game.value("length") },
    { id: "Tags", value: (game) => game.$tags.filter(t => t.startsWith("#game/")).join(" ") },
    { id: "Rating", value: (game) => game.value("rating") }
];

function timePlayed(input) {
    let raw = input.value("time played") ?? input.value("time-played");
    while (Array.isArray(raw)) raw = raw[0];

    if (typeof raw === "string") return undefined;
    return raw;
}

return function View() {
    const games = dc.useQuery("#game and @page");
    const grouped = dc.useArray(games, array => {
        return array
            .sort(x => timePlayed(x), 'desc')
            .groupBy(x => timePlayed(x)?.year)
            .sort(x => x.key, 'desc');
    });

    console.log(grouped);

    return (
        <dc.VanillaTable columns={COLUMNS} rows={grouped}/>
    );
}
```

There's some jankiness around fields right now since I need to improve the abstractions for dealing with nullable fields/different field types (I'll probably be adding a set of 'coerce' JS methods which just cast types to your desired type or return udnefined).


But the table abstraction is called `dc.VanillaTable` and currently supports configurable columns, arbitrary HTML rendering per column, and grouping.


I'm currently adding support for paging, and then I will add a basic list view.

After that I'll probably simplify handling fields in JS to simplify the `timePlayed` block in the current example code.

oh wow the code looks quite different now

Yes, Datacore JS uses react which does change how you write a codeblock quite a bit. The learning curve is different than the simpler dataview views, but there are a lot of upsides that coming with using react.

Views no longer flicker in Datacore, are generally faster to update, and now support interactivity everywhere - meaning you can have buttons, textboxes, checkboxes directly in tables, lists, and so on.



can't wait to spend a few months testing the new stuff once it is ready for brat

one thing i'm wondering is if the inline yaml knows where it is inside the note or if it get's combined with the other yaml


I'm going to start publishing actual releases very soon (this month) where it will be downloadable via BRAT.


Datacore separately tracks each YAML block as long as it is annotated with `yaml:data`.

You can separately search for/query each block and fetch all of it's data.


BRAT beta releases are now being published from this commit onwards.

How do I start using the beta release of DataCore if I don't have any coding background?

you can but it will be really hard because only the js part is working enough to test

The codeblock example above really helped me get started!

A working example for anyone interested (Of course, you need to install ver. 0.0.3 of datacore first.)

do you know how to index into this correctly?

Do you mean that you want to index content from section of note?

the $data holds the inline yaml codeblock data

I think I need to understand your requirements better because I have just started looking at the datacore documentation. Could you please specify your needs in detail? For example, what is the original format of the data, and how do you want the final data to be displayed (or what should it look like)? This way, I might be able to find a solution more quickly.


data like this and i just want to query it and display them in separate columns for each key.
(it can be that this isn't finished and not really supported yet)



```
---
test: 1
name: "Dovos"
when: 2023-05-21
file: "[[@Dovos]]"
---
```


```
---
test: 2
name: "Daniel"
when: 2000-05-21
file: "[[@Daniel @NL]]"
---
```

i should mention that i only know the basics of js through dataviewjs, so my knowledge about react specific things are limited

Maybe this will help.



`
```
const COLUMNS = [
  { id: "Link", value: (game) => game.$file },
  { id: "Name", value: (game) => game.value("name") },
  { id: "When", value: (game) => game.value("when") },
  { id: "Test", value: (game) => game.value("test") },
  { id: "File", value: (game) => game.value("file") }
];

return function View() {
  // Fetch pages containing @datablock
  const games = dc.useQuery("@datablock");
  
  const grouped = dc.useArray(games, array => {
    // Sort based on test value in descending order
    return array.sort((a, b) => b.value("test") - a.value("test"));
  });

  return (
    <>
      <h1>Basic list</h1>
      <dc.VanillaTable columns={COLUMNS} rows={grouped}/>
    </>
  );
}
```

I'm happy to help anyone write some basic UIs to get started... I'm doing Javascript first because it's what I personally use and I'd like to get all of the UI work in place before I add a simpler YAML/query based view.


i'm clueless on how to replicate queries like this
```js
const inlinks = dv.current().file.inlinks
const outlinks = dv.current().file.outlinks.mutate(t=> t.embed = false)
const indexA = Array.from({ length: Math.max(inlinks.length, outlinks.length) }, (_, index) => index)
const data = indexA.map((i)=> [inlinks[i] || " ", outlinks[i] || " "])
const style = "<span style='font-size:smaller;color:var(--text-muted)'>("

dv.table(["inlinks "+ style + inlinks.length +")", "outlinks "+ style + outlinks.length +")"], data)

this.container.querySelectorAll(".table-view-table tr:first-of-type th:first-of-type > span.small-text")[0].style.visibility = "hidden";
```


Are you looking to just have two columns of all inlinks and outlinks?

yes of the current note.
right now it also has a row per link


I'm not sure exactly what you want it to look like but what about something like this?

Do you want it vertical instead? Or just two columns?

I think the important thing here is there is no longer a constraint to fit things into just tables and list - you can emit arbitrary styling and HTML so you can make the view look broadly however you want.

I went a bit heavy on the styling but the code is this:
```jsx
return function View() {
    const current = dc.useCurrentFile();
    const incoming = dc.useQuery(`@page and linksto(id("${current.$path}"))`).filter(entry => entry.$link);
    const outgoing = dc.useQuery(`@page and linkedfrom(id("${current.$path}"))`).filter(entry => entry.$link);

    return (
        <table className="datacore-table">
            <tr>
                <td><b>Inlinks</b></td>
                <td>
                    {incoming.map(entry => (
                        <span style="margin: 4px; padding: 4px; background-color: var(--interactive-before);">
                            <dc.Link link={entry.$link}/>
                        </span>
                    ))}
                </td>
            </tr>
            <tr>
                <td><b>Outlinks</b></td>
                <td>
                    {outgoing.map(entry => (
                        <span style="margin: 4px; padding: 4px; background-color: var(--interactive-before);">
                            <dc.Link link={entry.$link}/>
                        </span>
                    ))}
                </td>
            </tr>
        </table>
    );
}
```


it really seems like that i have to relearn this instead of trying to get my dataview knowledge to fit into it
1. so much to learn

i'm too used to find what i need inside the log of the note and to just grab it from there

welp this will take some time to learn


i'm getting more outlinks than it should show. the only links i have are the ones the dataview query is showing

```
return function View() {
    const current = dc.useCurrentFile();
    const incoming = dc.useQuery(`@page and linksto(id("${current.$path}"))`).filter(entry => entry.$link);
    const outgoing = current.value("$links");
    //console.log(outgoing)
    return (
        <table className="datacore-table">
            <tr>
                <td><b>Inlinks</b></td>
                <td>
                    {incoming.map(entry => (
                        <span style="margin: 4px; padding: 4px; background-color: var(--interactive-before);">
                            <dc.Link link={entry.$link}/>
                        </span>
                    ))}
                </td>
            </tr>
            <tr>
                <td><b>Outlinks</b></td>
                <td>
                    {outgoing.map(entry => (
                        <span style="margin: 4px; padding: 4px; background-color: var(--interactive-before);">
                            <dc.Link link={entry.path}/>
                        </span>
                    ))}
                </td>
            </tr>
        </table>
    );
}
```


this works. the other outgoing query gives back the currents files outlinks AND the outlinks of the files it finds


I would love to see the code to go along with whatever screenshots you post in the future. Like the filter example. Or I thought I saw something about an interactive button? Stuff like that.
Is there a list of topics that I could study to learn how to build these things? React, JSX?

The magic is React + JSX, yes. I'll make a channel dedicated to just posting screenshots+associated code.

React can be a bit mind-breaking to grok, and it has some foot guns that can lead to bad performance, but you can do really cool stuff with it. And importantly, it's extensible enough that I can staple on a bunch of functionality to make views like this.


Im currently testing stuff to figure out a setup that i can use for my example vault, so im collection queries already.

(I have to sleep now tho)

Using react+jsx is great. And here is a demo for filter box and also sort:


```
// Config header and also query string here.
// Support sort and also filter box.
const query = `@page and path("Test datacore")`;
const columns_array = [
    { title: "Link", value: "$link" },
    { title: "Name", value: "name" },
    { title: "When", value: "when" },
    { title: "Test", value: "test" },
    { title: "File", value: "file" }
];

function View() {
    const games = dc.useQuery(query);
    const originGroup = dc.useArray(games, array => array);
    const [grouped, setGrouped] = dc.useState(originGroup);
    const [sortConfig, setSortConfig] = dc.useState({ key: null, direction: 'asc' });
    const [filter, setFilter] = dc.useState("");

    dc.useEffect(() => { applyFiltersAndSorting(); }, [originGroup, sortConfig, filter]);

    const columns = columns_array.map((c) => ({
        title: () => <span onClick={() => handleSort(c.value)}>{c.title}{getSortIndicator(c.value)}</span>,
        value: (game) => c.value.startsWith('$') ? game[c.value] : game.value(c.value)
    }));

    const handleSearch = (inputEvent) => {
        setFilter(inputEvent.target.value);
    };

    const applyFiltersAndSorting = () => {
        let filtered = originGroup;

        if (filter) {
            filtered = originGroup.filter((f) => {
                return Object.keys(f.$frontmatter).some((e) => 
                    e.toLowerCase().includes(filter.toLowerCase()) ||
                    f.$frontmatter[e].raw.toString().toLowerCase().includes(filter.toLowerCase())
                ) || f.$file.toLowerCase().includes(filter.toLowerCase());
            });
        }

        if (sortConfig.key) {
            filtered = filtered.sort((a, b) => {
                const aValue = sortConfig.key.startsWith('$') ? a[sortConfig.key] : a.value(sortConfig.key);
                const bValue = sortConfig.key.startsWith('$') ? b[sortConfig.key] : b.value(sortConfig.key);
                if (typeof aValue === 'string' && typeof bValue === 'string') {
                    return sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
                }
                return sortConfig.direction === 'asc' ? aValue - bValue : bValue - aValue;
            });
        }

        setGrouped(filtered);
    };

    const handleSort = (key) => {
        setSortConfig(prevConfig => ({
            key,
            direction: prevConfig.key === key && prevConfig.direction === 'asc' ? 'desc' : 'asc'
        }));
    };

    const getSortIndicator = (key) => {
        if (sortConfig.key === key) {
            return sortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }
        return '';
    };

    return (
        <>
            <div style={{ textAlign: "right" }}>
                <input onChange={handleSearch} placeholder="Search..." />
            </div>
            <dc.VanillaTable columns={columns} rows={grouped} />
        </>
    );
}

return <View />;
```

Support add or remove columns dynamically, sort when you click on the header, filter when you input in the input element.


Some notes -

1. You don't need the `dc.useArray()` call if you aren't doing anything - all it's doing is essentially converting the array to a `DataArray` and then back to a vanilla JS array, so it can be skipped.
2. You can use `<dc.Group justify="end">` instead of a text-aligned-div, which uses flexbox and is more general for aligning content.
3. I don't recommend using effects for the filters and sorting - I'd actually recommend `dc.useMemo()` instead, to memoize the current rows based on whatever the filter/sort state is. `useEffect` leads to an unneccessary re-render and can make things a bit harder to read.

Very cool though. You've already implemented some functionality I'm going to be adding eventually, haha.

There are also some existing utilities for sorting values in datacore internal code that I should expose to make that code easier.


Updated based on suggestions! Thanks for pointing them out.


# How to use

1. First, you need to config the query and also the `columns_array`;
2. Then, render it.


```
datacorejsx
// Config header and also query string here.
// Support sort and also filter box.
const query = `@page and path("Test datacore")`;
const columns_array = [
    { title: "Link", value: "$link" },
    { title: "Name", value: "name" },
    { title: "When", value: "when" },
    { title: "Test", value: "test" },
    { title: "File", value: "file" }
];

function View() {
    const games = dc.useQuery(query);
    const [sortConfig, setSortConfig] = dc.useState({ key: null, direction: 'asc' });
    const [filter, setFilter] = dc.useState("");

    const columns = columns_array.map((c) => {
        return c.value.startsWith('$') ? {
            title: () => <span onClick={() => handleSort(c.value, true)}>{c.title}{getSortIndicator(c.value)}</span>,
            value: (game) => game[c.value]
        } : { title: () => <span onClick={() => handleSort(c.value, false)}>{c.title}{getSortIndicator(c.value)}</span>, value: (game) => game.value(c.value) };
    });

    const filteredAndSortedGames = dc.useMemo(() => {
        let filtered = games;

        if (filter) {
            filtered = games.filter((game) => {
                return Object.keys(game.$frontmatter).some((key) => {
                    return key.includes(filter) || game.$frontmatter[key].raw.toString().includes(filter);
                }) || game.$file.includes(filter);
            });
        }

        if (sortConfig.key) {
            filtered = filtered.sort((a, b) => {
                const aValue = sortConfig.key.startsWith('$') ? a[sortConfig.key] : a[sortConfig.key].toString();
                const bValue = sortConfig.key.startsWith('$') ? b[sortConfig.key] : b[sortConfig.key].toString();
                return sortConfig.direction === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
            });
        }
        console.log(filtered);

        return filtered;
    }, [games, filter, sortConfig]);

    const handleSearch = (inputEvent) => {
        setFilter(inputEvent.target.value);
    };

    const handleSort = (key) => {
        let direction = 'asc';
        if (sortConfig.key === key && sortConfig.direction === 'asc') {
            direction = 'desc';
        }
        setSortConfig({ key, direction });
    };

    const getSortIndicator = (key) => {
        if (sortConfig.key === key) {
            return sortConfig.direction === 'asc' ? ' ‚Üë' : ' ‚Üì';
        }
        return '';
    };

    return (
        <>
            <dc.Group justify="end">
                <input onChange={handleSearch} />
            </dc.Group>
            <dc.VanillaTable columns={columns} rows={filteredAndSortedGames} />
        </>
    );
}

return <View />;

```


Oh, don't forget to remove console.log if anyone uses it.


Btw, is there any plan to expose function from Obsidian itself ? Like Notice and also setIcon function would be useful when create better layout for Table view.

I'm not familiar with either of those. What does `setIcon` do?

I really love this combination. I think for some it might be confusing at first, with no react experience, but with some experiences, if they know HTML they will be able to do a lot.

JSX I think is _mostly_ intuitive once you've seen it a few times - it's essentially just HTML templating. Everyone I've seen learn react goes through a learning curve though :)

Exactly, with a few examples I think people wont need to know much about react to do basic templating. they won't understand some of the code, but it won't matter, it is a very flexible templating system.

for example: setIcon(htmlelment, 'x') will give element a lucide-x icon

Oh, interesting. I can implement an icon element that renders lucide icons.


Sounds great!


In react it would look like an HTML element, probably something like `<dc.Icon icon={whatever}/>`

Going to actually add a documentation website now to document all of the current functionality. Time to go through the lovely dance of figuring out what the latest and most modern documentation generator is...

You can use gatsby haha


Beyond documentation, obviously, I'm curious if there are specific workflows people have that I should try to implement in the very near future.

My current next step is list views followed by inline field editing by default right now.


Maybe I can consider helping to create a basic select component.


I ever used dataviewjs to create a dynamic table before. A select component is important to it.

A select component would be helpful! You can either wrap the vanilla select component in HTML, or we can add a popover library to add support for arbitrary dropdowns.

Regular HTML select components are mostly limited in that they can only be simple text fields.

I can support basic vanilla select component first. And then if we decide to import popperjs or floatingui, we can move on next step.

Something that would have high value for me immediately would be the ability to add entities to an existing table (and other views) and have them automatically inherit the appropriate properties based on the table filters. One example is where I have a project page and a table with related tasks on that page (my tasks are files that have a property Project: [[Project 1]] etc). I want to be able to fly through and add a bunch of tasks that auto fill the Project property. 

Others are:
Being able to change text values in the table without opening the file, 
Some way to implement recurring tasks for file based tasks like changing another value when a button or checkbox is checked (that's probably not even in the scope of datacore), 
Being able to add simple metadata to a text block and query for it (say I have some quotes as simple text blocks throughout my vault and want to tag them as such and add their author as a property or want to list out some baby milestones with their date as a property but I don't want to make them entire files of their own)


Also    ...  magical inline checkboxes don't work in datacore views like they do dataview views so I guess either enabling that or adding interactive checkboxes for datacore.

I have also encountered this issue, but I plan to wait for datacore to support variable components. That way, I can embed it directly into the datacore view.

Made some useful components including the select component (I have introduced Obsidian's CSS classes in some components to make them look more like native Obsidian elements.)

Custom views, or are those obsolete now?

like `dc.view()`

Custom views are mostly obsolete but loading views as "templates" is definitely on my list.

What support do you need? I can add it this week.


The editing functionality is coming soon - including being able to tie checkboxes to editing other state.

"Add new file" is interesting - I think it will be possible soon though it will need a bit of work to look smooth, since there is a bit of lag by default between writing a file and Obsidian tracking Metadata for it.

A way to update the metadata?

Although it is now possible to support custom way to update a data from note. But I want a better way or hook? to update it in Table view.


the plan is that it is that you can change the values of the metadata from the rendered table/list without going into the note like db folder or metadata menu allows it.


i noticed that the tasks objects don't have the tasks text as field. is this a mistake on my side or a bug?
also how do i get only the elements of the current node inside dc.useQuery()? i tried
```
dc.useQuery(`@task and path = '${current.$path}'`)
dc.useQuery(`@task and path('${current.$path}')`)
dc.useQuery(`@task and path(id('${current.$path}'))`)
```
but they all don't work


the section/header name is also missing for both _markdownListBlock and _MarkdownTaskItem. does that mean i have to go up the parent field until i'm at the _MarkdownSection object to get the name? if yes is there a way to include that directly in dc.useQuery()? (i don't understand how the filter in useQuery work besides for the main frontmatter fields


```
return function View() {
    const current = dc.useCurrentFile();
    //const tasks = dc.useQuery(`@task and $completed`)
    const allTasks = current.$sections.filter(s => s.$title == "Status Tasks").map(s => s.$blocks).flat().filter(b => b.$type == "list").map(l => l.$elements).flat();
    const completedTasks = allTasks.filter(t => t.$completed).length;
    return (
        <span style="margin: 4px; padding: 4px;">
            <progress value ={completedTasks} max ={allTasks.length}/>
            {Math.round(completedTasks / allTasks.length * 100 )}% | {allTasks.length - completedTasks} left
        </span>
    );
}
```

```jsx
return function View() {
    const current = dc.useCurrentFile();
    //const tasks = dc.useQuery(`@task and $completed`)
    const allTasks = current.$sections.filter(s => s.$title == "Status Tasks").map(s => s.$blocks).flat().filter(b => b.$type == "list").map(l => l.$elements).flat();
    const completedTasks = allTasks.filter(t => t.$completed).length;
    return (
        <span style="margin: 4px; padding: 4px;">
            <progress value ={completedTasks} max ={allTasks.length}/>
            {Math.round(completedTasks / allTasks.length * 100 )}% | {allTasks.length - completedTasks} left
        </span>
    );
}
```
almost. now i just need it as inline query. my guess it isn't supported yet

this might be a very beginner question, but how can you use datacore(js/jsx/ts/tsx) to display a list of pages or even just a table ? 

here's the code I tried (datacorejsx) using to make a list of files in my daily notes folder (I have a tag, but for some reason using the tag in the query only got a single result ?) 


```
return function View() {
return dc.api.query('@page and path("¬ßPeriodic Notes/Daily")').map((i)=> "- " + i.$file)
}
```

instead of a list of links (which aren't clickable!), it returns the text in the format of `[[filename]] - [[filename]] - [[filename]] -...`

AAAHH I wasn't using dc.useQuery, I'll try this once I get to my desktop!

unless I have dc installed but disabled on my phone I have to chdck

it can be that mobile isn't working yet. haven't tested it tho

ah yeah it isn't installed despite it being added to BRAT

Hey üëã  I have a question that might sound dumb but I cannot find a response in the docs on GitHub.
Is this intended that the `#tag` notation in `useQuery` doesn't support files where the actual tag is defined within the `tags` key in their yaml frontmatter?

No, those should also work. Though maybe it's broken ü§î

I'm afraid it's a bug then. Would you like me to open an issue?

How do I call a .js file?

This code allows my file to be found.

```datacorejsx
const View = await dc.require(dc.headerLink("scripts/datacore.js"));
return View(dc);
```

It returns this error:
```
The datacore script failed to execute.

Error: .parse must be called with a string or Buffer as its argument
    at u4.parse (plugin:datacore:408:19)
    at u4.tryParse (plugin:datacore:412:25)
    at normalizeHeaderForLink (plugin:datacore:12039:31)
    at Link.header (plugin:datacore:12098:16)
    at DatacoreLocalApi.headerLink (plugin:datacore:36783:17)
    at eval (eval at evalInContext (plugin:datacore), <anonymous>:3:56)
    at eval (eval at evalInContext (plugin:datacore), <anonymous>:4:20)
    at evalInContext (plugin:datacore:34632:39)
    at asyncEvalInContext (plugin:datacore:34636:12)
    at renderer (plugin:datacore:34812:22)
```
 When I modify the code to this:
```datacorejsx
const View = await dc.require("scripts/datacore.js");
return View(dc);
```
It returns:

```
The datacore script failed to execute.

Error: Could not find a script at the given path: scripts/datacore.js
    at Failure.orElseThrow (plugin:datacore:12611:13)
    at DatacoreLocalApi.require (plugin:datacore:36763:19)
    at async eval (eval at evalInContext (plugin:datacore), <anonymous>:3:36)
    at async renderer (plugin:datacore:34812:16)
```

What's the proper syntax when using a .js file instead of a .md file? My issue is with `dc.headerLink`, and me wanting to remove it, but when I do, my script cannot be found.


I've fixed this in beta release 0.1.13, which I've just released.


I've fixed the `dc.require("scripts/datacore.js")` require - this was an issue with JS files not always showing up in the datacore index. The fix is available in beta 0.1.14.



Thank you SO much. My mind can't stop comparing you to a fireman. Reliable and Dependable and Quick

he's absolutely brilliant 


Wow that was fast! Thank you very much üôè

Hey everyone, I just wanted to ask a question about pagination as it has been ticked off on the roadmap but when I created a vanilla table with over 100 records, it didn't break off at 50. Is it not available yet or am I missing something?

I haven‚Äôt figured it out yet either. I gave up because my table kept freezing obsidian. I might try again today though.

```
<dc.VanillaTable groupings={GROUPINGS} columns={COLUMNS} rows={grouped} paging={12}/>
```

Bless you


Another question. Do I have to map fields when they're nested in order to access them?


depends on how they are nested and what you want to get out of them

Okay. I'm about to start playing with the console and extract fields function to see how they qualify.


have fun
1. i won't be of much help


Thank you so much!


Also I just got two other questions, I'm having trouble with getting a query like `dc.useQuery("@page and #game and rating >= 8")` to work. The table shows no results despite my notes having a YAML property called rating. And how do you sort based on multiple properties like sort by priority and then by date? (sorry if it's a dumb question I'm still a newbie at JavaScript)


where is the yaml defined? frontmatter?

if it's in frontmatter, you need to do `$frontmatter.rating >= 8`

Oooh I see, thanks for that appreciate it

And what about for sorting based on multiple properties?

if there's only two properties you want to sort on, you can wrap `useQuery` in a `DataArray` and group the results using something like `dc.array(dc.useQuery(...)).groupBy(...).sort(...)`

i think it's possible to display deeply nested groups in a table, but don't quote me on that

Fantastic that works, thank you

You don't need to groupBy to sort on multiple - just use an array in your sort function.
```jsx
const raw = dc.useQuery("blah and blah");
const sorted = dc.useArray(raw, array => {
  return array.sort(element => [element.$name, element.value("rating")]);
});
```

This query should work as is without needing to be changed - the reason it doesn't is a bug which will be fixed in the next beta release.

I see got it thanks for the info

What if you wanted one in ascending order and one in descending though?

If one of the fields is numeric you can just negate it, otherwise I probably need to expose a new api on DataArray to make this easier. I think it would be something kind of wierd like:

```jsx
const raw = dc.useQuery("blah and blah");
const sorted = dc.useArray(raw, array => {
  return array.sort(element => element, undefined, (first, second) => {
    // Sort first one ascending.
    const keyOne = array.defaultComparator(first.$blah, second.$blah);
    if (keyOne != 0) return keyOne;

    // Second one descending.
    const keyTwo = array.defaultComparator(first.$foo, second.$foo);
    return -keyTwo;
  });
});
```

I see I see thanks for all the help

I provided an example using a custom comparator which would scale to any number of properties.


That's perfect, thanks for all that really appreciate it


I cannot figure out how to access each value within the nested structure and get it to populate a cell in a table.
My nested property is set up like this:
```
Key: mathlink-blocks, Value: {AltNotation: null, LinkedDimensions: null, LinkedStaticDimensions: null, MKS: null, CGS: null, FPS: null, LinkedFormula: null, Dimensions: null, StaticDimensions: null, Formula: null, Formula1: null, Formula2: null, Formula3: null, Formula4: null, Formula5: null, LinkedFormula1: null, LinkedFormula2: null, LinkedFormula3: null, LinkedFormula4: null, LinkedFormula5: null, ParentVariable: null}
```

The above is just a structure example. All of my values are not null.

I've tried `$frontmatter.mathlink-blocks.value.mks.value`, `$frontmatter.mathlink-blocks.mks.value`, `$frontmatter.mathlink-blocks.mks`, `mathlink-blocks.value.mks.value`, `mathlink-blocks.mks.value`, and `$frontmatter.mathlink-blocks.mks`.


did you use console.log() to see what you are getting as data?

and where inside the code are you trying to access it?

and where is that metadata? is it inside the frontmatter or inside inline yaml?

The data populates in the place of `null`. The data is in the frontmatter. I am trying to place the data into the columns sections of a table.

i don't think your data is even valid in the way you think it is

It works in dataview. I assumed it would work in datacore. Define valid.

to understand you correctly. what exactly do you have inside the note? just copy paste this or a different version of this? (ignoring the null values)

Okay. One second. I have to run to the computer.

```
mathlink-blocks: {AltNotation: null, LinkedDimensions: null, LinkedStaticDimensions: null, MKS: null, CGS: null, FPS: null, LinkedFormula: null, Dimensions: null, StaticDimensions: null, Formula: null, Formula1: null, Formula2: null, Formula3: null, Formula4: null, Formula5: null, LinkedFormula1: null, LinkedFormula2: null, LinkedFormula3: null, LinkedFormula4: null, LinkedFormula5: null, ParentVariable: null}
```

This is the console log of a the mathlink-blocks field from a specific page.
```
Key: mathlink-blocks, Value: {AltNotation: ${\color{Melon}T}$, Dimensions: $\boldsymbol{\theta}$, LinkedDimensions: null, StaticDimensions: null, LinkedStaticDimensions: null, MKS: $\boldsymbol{T}[\pu{K}]$, CGS: $\boldsymbol{T}[\pu{\degree{C}},\pu{K}]$, FPS: $\boldsymbol{T}[\pu{\degree{F}},\degree{R}]$, Formula: $\Delta {\color{Melon}T}$, Formula1: ${\color{brown}T_{s}}_{in}[\pu{K}]-{\color{brown}T_{s}}_{out}[\pu{K}]$, Formula2: ${\color{brown}T_{s}}-{\color{orange}T_{\infty}}$, Formula3: ${\color{red}T_{H}}-{\color{blue}T_{C}}$, Formula4: null, Formula5: null, LinkedFormula: <span class="center-align">[[Change in]] [[Temperature#^AltNotation]]</span>, LinkedFormula1: <span class="center-align"><sup>[[Surface Temperature]]-[[Surface Temperature#^AltNotation]]</span></span>, LinkedFormula2: <span class="center-align"><sup>[[Surface Temperature#^AltNotation]]-[[Surroundings Temperature]]</span></span>, LinkedFormula3: <span class="center-align"><sup>[[Hot Temperature]]-[[Cold Temperature]]</span></span>, LinkedFormula4: null, LinkedFormula5: null, ParentVariable: null}
```

and what is the raw yaml?


```
---
parent:
  - "[[Glossary/Dimensions/Dimensions|Dimensions]]"
fileClass: Dimensions
mathLink: $\boldsymbol{T}[\pu{K,\degree{C},\degree{F},\degree{R}}]$
mathLink-blocks:
  AltNotation: ${\color{Melon}T}$
  Dimensions: $\boldsymbol{\theta}$
  LinkedDimensions: 
  StaticDimensions: 
  LinkedStaticDimensions: 
  MKS: $\boldsymbol{T}[\pu{K}]$
  CGS: $\boldsymbol{T}[\pu{\degree{C}},\pu{K}]$
  FPS: $\boldsymbol{T}[\pu{\degree{F}},\degree{R}]$
  Formula: $\Delta {\color{Melon}T}$
  Formula1: ${\color{brown}T_{s}}_{in}[\pu{K}]-{\color{brown}T_{s}}_{out}[\pu{K}]$
  Formula2: ${\color{brown}T_{s}}-{\color{orange}T_{\infty}}$
  Formula3: ${\color{red}T_{H}}-{\color{blue}T_{C}}$
  Formula4: 
  Formula5: 
  LinkedFormula: <span class="center-align">[[Change in]] [[Temperature#^AltNotation]]</span>
  LinkedFormula1: <span class="center-align"><sup>[[Surface Temperature]]-[[Surface Temperature#^AltNotation]]</span></span>
  LinkedFormula2: <span class="center-align"><sup>[[Surface Temperature#^AltNotation]]-[[Surroundings Temperature]]</span></span>
  LinkedFormula3: <span class="center-align"><sup>[[Hot Temperature]]-[[Cold Temperature]]</span></span>
  LinkedFormula4: 
  LinkedFormula5: 
  ParentVariable: 
aliases: 
Type: Dimension
related:
  - "[[Change in]]"
dimensions: 
staticdimensions: 
definition: 
title: Temperature

---
```

now that is something i can work with

Thank you, preemptively.

{ id: "AltNotation", value: (file) => file.value("mathLink-blocks").AltNotation}


i still don't understand how to correctly use dc.useQuery() besides with `@page and #tag`

```
const COLUMNS = [
    { id: "File", value: (file) => file.$link},
    { id: "AltNotation", value: (file) => file.value("mathLink-blocks").AltNotation}
];

return function View() {
    const qdata = dc.useQuery(`@page and #datacore`);
    console.log(qdata)
    return (
        <dc.VanillaTable columns={COLUMNS} rows={qdata} paging= {20}/>
    );
}
```

```jsx

let COLUMNS = [
    { id: "File", value: (file) => file.$link}
];

function addColumn(field){
    for(let name in field[0]){
        COLUMNS.push({id: name, value: (file) => file.value("mathLink-blocks")[name]})
    }
}


return function View() {
    const qdata = dc.useQuery(`@page and #datacore`);
    addColumn(qdata.map(file => file.value("mathLink-blocks")))
    //console.log(qdata)
    console.log(COLUMNS)
    return (
        <dc.VanillaTable columns={COLUMNS} rows={qdata} paging= {20}/>
    );
}

```
i have a js moment... why isn't it putting in the value of name into the [name] place? the id: works fine


Welp....It took me around 15 minutes to force it to work. I tried over 15 variations, and this is the query that actually works.

```datacorejsx
const COLUMNS = [
    { id: "File", value: (file) => file.$link},
    { id: "AltNotation", value: (file) => file.value("mathLink-blocks").AltNotation}
];

return function View() {
    const qdata = dc.useQuery(`@page and path("Glossary/Variables")`);
    console.log(qdata)
    return (
        <dc.VanillaTable columns={COLUMNS} rows={qdata} paging= {20}/>
    );
}
```

When I set qdata to ``dc.useQuery(`@page and path("Glossary")`);``, it failed. `@page`, ``@page and path("Glossary/")`, and `@page and path("Glossary/Dimensions")` all failed to render a table with results. 

But I want to say THANK YOU!!!. I really appreciate it.

now the query above works
i forgot the let..

1. the only problem is that it is too many fields

Oh my god, you automated it. THANK YOU!!!


1. it still isn't enough to show all

I scroll a lot. I usually just transform my tables into cards to help me see everything.


that makes sense

1. the tables are missing a scroll bar for tables with overwidth


Table scrollbars are hard since it messes with the automatic column sizing... is just an `overflow-x: scroll` good enough?

Following up on this - this query behavior is fixed in 0.1.15 so you can do `rating >= 8` again.

I just mean that if we make big queries like this, not even zooming out completely will show all columns. Sure it would be better to just be more selective with the columns but a table gets quite small if readable line length is on.


Oh, readable line length. I don't use that setting very often so I haven't really been designing things with it in mind.

I can add an optional scroll bar.


can't the table be vertical?


It can be, you just need to make it yourself.

Can we do inline queries yet? Dataview inline queries break in read mode.d

Sorry for the super basic question, but where can I find detailed documentation on how to use the now used jsx query language? I‚Äôm just trying to get a list of files in a folder, but can‚Äôt figure it out, since the examples I‚Äôve found shared don‚Äôt seem to do something like this.

Don‚Äôt know if we have lists yet, but a table:

```datacorejsx
const COLUMNS = [
    { id: "File", value: (file) => file.$link}
];

return function View() {
    const qdata = dc.useQuery(`@page and path("folder name")`);
    
    return (
        <dc.VanillaTable columns={COLUMNS} rows={qdata} />
    );
}
```

Thank you so much for the example!

`{ id: "Tags", value: (file) => file. $tags}` I think.



If you want a bullet point list you can use:

```
return dc.api.query('@page and path("your/folder/path")').map(i => "- " + i.$link)
```

1. I think there are some other examples of lists in the GitHub docs


Has there been any improvements to this? Links that contain `^` and `#` are not returning.


hello, how do I query based on DateTime? `dc.date()` doesn't work as well as `new DateTime`


Using a date expression inside of the query itself: `dc.useQuery("time > date(2024-10-10)")`; you can also compare datetimes directly I think with `<` so you could manually filter the result...

```
const items = dc.useQuery("blah blah");
const filtered = dc.useArray(items, array => array.where(item => item.value("time") > new DateTime(...)));
```

Luxon might have a dedicated compare function? I do not remember.


I tried using DateTime and I get an error DateTime is not defined

try `dc.luxon.DateTime`


Is it possible to use custom html with working `file.$link`? So far it only works in dc.VanillaTable or list variant, any other html like <span> display empty

jsx <span> is not html

1. it just looks like it

Can you elaborate, the second I put page.$link in a fragment it's blank

well i need your code to know what you try to do.


also i'm new to jsx too so i might not actually be able to help


I found the solution yesterday, basically I wanted the link to render, using `<a class="internal-link" data-href={page.$path}>{page.$name}</a>` works, and I also found `<dc.Link link={page.$link} />` is also a thing, is there a document exposing all the API?


the docs aren't finished yet. you basically need to read through the source code to find all available functions

Hi, long-time lurker here. Thanks for the great work. Excited about the tool's progress!
I'm using Dataview a lot, but lately Obsidian keeps crashing and reloading on mobile as long as it's enabled.

My hope would be that with Datacore I could replace DV and write simple queries that require far less resources (especially putting less strain on indexing in a fairly large vault).
Is that a realistic hope? And would now be a good time to invest some time rewriting queries and switching to DC?


Thanks! Yeah, I remember seeing the benchmark. That's awesome!
Would you recommend the usage of DC on mobile in its current state?

I don't know

1. I wonder if anyone has made plugins on it?
Does anyone have examples of editing fields they can share please?



What do you mean by editing fields?



Editing frontmatter within the native page query or table

Such as metadata menu, if I am undertsanding correctly

Perhaps "editable fields" is a better word

Let's see if other have some

It's out?!? I didn't even know that update had been pushed.

That‚Äôs this one?

that's on a different branch ‚Äî it even says "WIP"

I saw the wip, but the main branch says the whole project is wip so I wasn‚Äôt sure if it is available for people yet

It isn't available until a new release version is made. 
That is even if the commit is to the master branch. You would need to built the version yourself without the release version

Got it now, thank you

Is there a way to query all `@block` that are inside every `@section` named a specific way?

`@block and childof(@section and $title = "name")`

Hi, It seems list item has no $text property, how to query list items, containing some text?

It will in the next release.

Ok, thanks.


inside of a query, how do I change the way date is parsed? In Luxon you can do `.fromFormat()` but how would I do that in a query, something like `@section AND date($title, "DDD")`










